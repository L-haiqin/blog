### 同步和异步

js执行模式分为：同步和异步。

#### 同步模式

js是一门单线程语言，所谓"单线程"，就是指一次只能完成一件任务。如果有多个任务，就必须排队，**前面一个任务完成，再执行后面一个任务**，以此类推。**如果一个任务耗时过长，那么后面的任务就必须一直等待下去，会拖延整个程序，常见浏览器无反应**，可能就是一段代码死循环，造成程序卡住在这个位置，无法继续。

程序的执行顺序与任务的排列顺序是一致的、同步的 。

#### 异步模式

##### 概念

每一个任务有一个或多个**回调函数**（callback），**前一个任务结束后，不是执行后一个任务，而是执行回调函数，后一个任务则是不等前一个任务结束就执行**，所以程序的执行顺序与任务的排列顺序是不一致的、异步的。

##### 异步运行机制

 （1）所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。

 （2）主线程之外，还存在一个"任务队列"（task queue）。只要异步任务有了运行结果，就在"任务队列"之中放置一个事件。

 （3）一旦"执行栈"中的所有同步任务执行完毕，系统就会读取"任务队列"，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。

 （4）主线程不断重复上面的第三步。

##### 异步模式编程的四种方法

###### （1）回调函数

假定有两个函数f1和f2，后者等待前者的执行结果。

> f1();
>
> f2();

如果f1是一个很耗时的任务，可以考虑改写f1，把f2写成f1的回调函数。

```javascript
　　function f1(callback){

　　　　setTimeout(function () {

　　　　　　// f1的任务代码

　　　　　　callback();

　　　　}, 1000);

　　}
```

执行代码就变成下面这样：

> f1(f2);

采用这种方式，我们**把同步操作变成了异步操作，f1不会堵塞程序运行，相当于先执行程序的主要逻辑，将耗时的操作推迟执行。**

> 比如加载bundle的时候，i18n、session等init是同步执行的话，会很耗费时间，所以考虑在require bundle的时候调一下异步执行，具体结果等到我们需要的时候再await。
>
> [多个promise并发执行，如果某个promise失败，则尝试重新执行该promise一次，如果还是失败则提示错误](https://blog.csdn.net/weixin_43973415/article/details/132451331)

回调函数的优点是简单、容易理解和部署，缺点是不利于代码的阅读和维护，各个部分之间高度[耦合](https://en.wikipedia.org/wiki/Coupling_(computer_programming))（Coupling），流程会很混乱，而且每个任务只能指定一个回调函数。

###### （2）事件监听：任务的执行不取决于代码的顺序，而取决于某个事件是否发生

###### （3）发布订阅模式，也叫观察者模式

###### （4）Promises对象 

最基础的异步是setTimeout和setInterval函数，很常见，但是很少人有人知道其实这就是异步，因为它们可以控制js的执行顺序 。

博客来源：[Javascript异步编程的4种方法](http://www.ruanyifeng.com/blog/2012/12/asynchronous%EF%BC%BFjavascript.html)

