### 动态规划

#### 引言

常见的思路：

- 穷举法/暴力搜索，画出递归树，通过递归实现，但时间复杂度太大
- 记忆化搜索/剪枝，如果存在大量重复计算的步骤，可以考虑用一个哈希值记录下来，不用每次都计算
- 迭代
- 重点：动态规划转移方程
- 初始化数组：`const dp = new Array(nums.length).fill(1)`或`const dp = new Array(m + 1).fill(0).map(() => new Array(n + 1).fill(0))`

#### 一维

##### 1、连续子数组的最大和

来源：[剑指 Offer 42. 连续子数组的最大和](https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/)

输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。

要求时间复杂度为O(n)。

```
示例:

输入: nums = [-2,1,-3,4,-1,2,1,-5,4]
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
```

题解：

```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */

var maxSubArray = function(nums) {
    let pre = 0, maxAns = nums[0];
    console.log(maxAns)
    nums.forEach((x) => {
        pre = Math.max(pre + x, x);
        maxAns = Math.max(maxAns, pre);
    });
    return maxAns;
};
```

- f(i) 代表以第 i个数结尾的「连续子数组的最大和」
- 那么我们如何求 f(i)呢？我们可以考虑` nums[i]`单独成为一段还是加入 f(i−1)对应的那一段，这取决于 `nums[i]`和 `f(i−1)+nums[i]`的大小，我们希望获得一个比较大的，于是可以写出这样的动态规划转移方程：

  - `f(i)=max⁡{f(i−1)+nums[i],nums[i]}`

复杂度：

- 时间复杂度：O(n)，其中 n 为 nums数组的长度。我们只需要遍历一遍数组即可求得答案。
- 空间复杂度：O(1)。我们只需要常数空间存放若干变量。

##### 2、最长公共子序列

来源：[1143. 最长公共子序列](https://leetcode-cn.com/problems/longest-common-subsequence/)

给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。

```
示例 1：

输入：text1 = "abcde", text2 = "ace" 
输出：3  
解释：最长公共子序列是 "ace" ，它的长度为 3 。
```

题解：

```javascript
var longestCommonSubsequence = function(text1, text2) {
    const m = text1.length, n = text2.length;
    const dp = new Array(m + 1).fill(0).map(() => new Array(n + 1).fill(0)); // 二维数组的创建方法
    for (let i = 1; i <= m; i++) {
        const c1 = text1[i - 1];
        for (let j = 1; j <= n; j++) {
            const c2 = text2[j - 1];
            if (c1 === c2) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
            } else {
                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }
    return dp[m][n];
};
```

- 状态转移方程：其中 `dp[i][j] `表示 `text1[0:i] `和 `text2[0:j]` 的最长公共子序列的长度。
- `text1[0:i]` 表示 `text1 `的长度为 i 的前缀，`text2[0:j] `表示` text2 `的长度为 j的前缀
  - 当`text[i-1]==text2[j-1]`，`dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1])`
  - 当`test1[i-1]!=test2[j-1]`，`max(dp[i-1][j], dp[i][j-1])`
- 动态规划的边界情况是：当 i=0或 j=0 时，`dp[i][j]=0`
- 最终计算得到的`dp[m][n]`即为最长公共子序列的长度。m、n分别表示test1和test2的长度。

复杂度：

- 时间复杂度：O(mn)，其中 m和 n 分别是字符串 text1和 text2的长度。二维数组 dp 有 m+1行和n+1 列，需要对 dp中的每个元素进行计算。

- 空间复杂度：O(mn)，其中 m 和 n 分别是字符串 text1 和 text2 的长度。创建了 m+1 行 n+1 列的二维数组 dp。

##### 3、最长递增子序列

来源：[300. 最长递增子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)

给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。

```
示例 1：

输入：nums = [10,9,2,5,3,7,101,18]
输出：4
解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。
```

题解：

```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var lengthOfLIS = function(nums) {
    const dp = new Array(nums.length).fill(1)
    for (let i = 0; i < nums.length; i++) {
        // i与i前面的元素比较
        for (let j = 0; j < i; j++) {
            // 找比i小的元素，找到一个，就让当前序列的最长子序列长度加1
            if (nums[i] > nums[j]) {
                dp[i] = Math.max(dp[i], dp[j] + 1)
            }
        }
    }

    // 找出最大的子序列
    let res = 0
    for (let i = 0; i < dp.length; i++) {
        res = Math.max(res, dp[i])
    }
    return res
};
```

- DP数组用来存储该位置的最长子序列长度。

- 设nums[j] < nums[i]，` dp[i] = Math.max(dp[i], dp[j] + 1)`，即上一个比它小的数的最长子序列加1。

- 遍历dp数组，找出最大值。

复杂度：

- 时间复杂度：O(n^2)
- 空间复杂度：O(n)

##### 4、可被三整除的最大和

来源：[1262. 可被三整除的最大和](https://leetcode-cn.com/problems/greatest-sum-divisible-by-three/)

给你一个整数数组 nums，请你找出并返回能被三整除的元素最大和。

```
示例 1：

输入：nums = [3,6,5,1,8]
输出：18
解释：选出数字 3, 6, 1 和 8，它们的和是 18（可被 3 整除的最大和）。
```

题解：

```javascript
var maxSumDivThree1 = function(nums) {
    let state = [0, Number.MIN_SAFE_INTEGER, Number.MIN_SAFE_INTEGER];

    for (let num of nums) {
        if (num % 3 === 0) {
            state = [state[0] + num, state[1] + num, state[2] + num ]
        } else if (num % 3 === 1) {
            const a = Math.max(state[2] + num, state[0]);
            const b = Math.max(state[0] + num, state[1]);
            const c = Math.max(state[1] + num, state[2]);
            state = [a, b, c];
        } else if (num % 3 === 2) {
            const a = Math.max(state[1] + num, state[0]);
            const b = Math.max(state[2] + num, state[1]);
            const c = Math.max(state[0] + num, state[2]);
            state = [a, b, c];
        }
    }
    return state[0];
};
```

- state数组分别表示mod为0、1、2的最大和

复杂度：

- 时间复杂度：O(n)
- 空间复杂度：O(n)



```javascript
function f(n,arr){

//let n = parseInt(readline());
//let arr = readline().split(' ').map((a) => parseInt(a)).sort((a, b) => a - b);
let canComTri = new Array(n).fill(0);
for (let i = 0; i < n - 2; i++) {
    for (let j = i + 1; j < n - 1; j++) {
        for (let k = j + 1; k < n; k++) {
            if (arr[k] < arr[i] + arr[j]) {
                canComTri[i]++;
                canComTri[j]++;
                canComTri[k]++;
            } else {
                break;
            }
        } 
    }
}
let res = [];
    console.log('canComTri:', canComTri)
let max = Math.max(...canComTri);
for (let i = 0; i < n; i++) {
    if (canComTri[i] === max) res.push(arr[i]);
}
console.log(res.join(' '))
}
f(6,[2,6,3,5,1,7])
```

#### 二维

