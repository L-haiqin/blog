### 模版引擎

百度社招面试题

```js
// 编写 format 函数，实现 模板字符串填充：
function format(tpl, tplData) {
    // TODO
    return tpl.replace(/{{(.*?)}}/g,($0, value)=>{
        // tplData.title
        // tplData.tplData.title
        let res = tplData;
        value.split('.').forEach(i=>{
            res = res[i];
        })
        return res;
    })
}
console.log(format('{{title}}', {title: 'abc'}));
// 输出结果：abc
console.log(format('{{tplData.title}} - {{tplData.desc}}', {tplData: {title: 'abc', desc: 'def'}}));
// 输出结果： abc - def
```

### 根据json path取值

滴滴社招面试题

```js
var object = { a: [{ b: { c: 3 } }] }; // path: 'a[0].b.c'
var array = [{ a: { b: [1] } }]; // path: '[0].a.b[0]'
console.log(getValue(object, "a[0].b.c")); // 输出3
console.log(getValue(array, "[0].a.b[0]")); // 输出 1

// 实现
const getValue = (obj, path) => {
    return path
        .replace(/$$([^\[$$]*)\]/g, '.$1.')  // 将 [index] 转换为 .index.
        .split('.')                          // 分割路径为数组，比如['a','0','b','c']
        .filter(prop => prop !== '')         // 过滤空字符串
        .reduce((prev, next) => {
            return (prev !== null && prev !== undefined) ? prev[next] : null;
        }, obj) || null;                     // 遇到无效路径返回 null
};
```

对path进行正则解析，数字匹配数组，字母匹配对象。

> 最开始的想法是：字符串.分割 ==> 遍历 ==> 提取[]里面的数字 ==> 再访问对象
>
> 上面给出的思路：将所有key都分解出来 ==> 直接访问对象
>
> ```js
> [1,2,3]['0'] // 输出1
> ```
>
> 这里数字index也可以用字符串访问

区别于：shark之前做了一个点击元素获取json path

### 对象扁平化

滴滴社招面试题

```js
let input = {
  a:1,
  b:[1,2,{c:true},[3]],
  d:{e:2,f:3},
  g:null
}

let output={
  a:1,
  'b[0]':1,
  'b[1]':2,
  'b[2].c':true,
  'b[3][0]':3,
  'd.e':2,
  'd.f':3,
  g:null // 值为null需要丢弃
}

const flatten=(input) => {
  let res = {};

  // 对value和path进行递归处理
  const traverse = (current, path) => {
    if (current === null) {
      return;
    } else if (Array.isArray(current)) {
      current.forEach((v, i) => {
        traverse(v, `${path}[${i}]`); // path也需要递归透传下去
     })
    } else if (typeof current === 'object') {
      Object.entries(current).forEach(([k, v]) => {
        traverse(v, `${path}.${k}`); // path也需要递归透传下去
      })
    } else {
      res[path] = current;
    }
  }

  Object.entries(input).forEach(([k, v]) => traverse(v, k));

  return res;

  // 下面这种递归的写法不能实现扁平化
  // for (let k in input) {
  //   const value = input[k];
  //   if (typeof value !== 'object') {
  //     res[k] = value;
  //   } else{
  //     res[k] = flatten(value);
  //   }
  // }
}

console.log(flatten(input))
```

### 嵌套对象的深度

滴滴社招面试题

```js
// 编写一个函数，计算给定嵌套对象的深度。对象的深度定义为从最外层到最深嵌套属性的层级数。
const obj1 = {
  a: 1,
  b: {
    c: 2,
    d: {
      e: 3
    }
  }
};
// 深度为3 (b -> d -> e)

function deep(obj) {
    let res = 0;
    Object.entries(obj).forEach(([key, value]) => {
        if (typeof value === 'object') {
            res += deep(value);
            console.log(res)
        } else {
            res += 1;
        }
    })
    return res;
}

console.log(deep(obj1))
```

### 对象数组的valuePath

美团社招面试题

请编写函数，其参数为下列树结构，该函数需将参数中每节点的字段 id 转为 value，并在每个节点生成当前节点距离顶层的路径valuePath

```js
const srcTree = [
  // 源数据
  {
    id: 1,
    name: "测试 1",
    children: [
      {
        id: 11,
        name: "测试 1-1",
      },
    ],
  },
];

const distTree = [
  // 结果
  {
    value: 1,
    valuePath: [1],
    name: "测试 1",
    children: [
      {
        value: 11,
        valuePath: [1, 11],
        name: "测试 1-1",
      },
    ],
  },
];
```

```js
function fun(origin) {
  return deep(origin, []);
}

function deep(origin, path) {
  return origin.map((item) => {
    let cur = {
      name: item.name,
      value: item.id,
      valuePath: [...path, item.id],
    };
    if (item?.children) {
      cur.children = deep(item?.children, [...path, item.id]);
    }
    return cur;
  });
}
```







