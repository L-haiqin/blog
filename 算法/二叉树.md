### 1、深度优先搜索

来源：[102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

给你一个二叉树，请你返回其按 **层序遍历** 得到的节点值。 （即逐层地，从左到右访问所有节点）。

> 输入：[3,9,20,null,null,15,7]
>
> 输出：[[3], [9,20], [15,17]]

深度优先搜索(Depth First Search)(其实是**二叉树的先序遍历**)是沿着树的深度遍历树的节点，尽可能深的搜索树的分支。

关键点：**递归**

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[][]}
 */
var levelOrder = function(root) {
    if(!root) return [];
    let result = [];  // 存放结果
   
    // 深度优先搜索(Depth First Search)(其实是**二叉树的先序遍历**)是沿着树的深度遍历树的节点，尽可能深的搜索树的分支。
    dfs(root,0,result);
    return result;
};

function dfs(root,step,result){
    if(root){
        if(!result[step]) result[step] = [];  // 此判断必须这样写，result[step] ==== null 无效
        result[step].push(root.val);  // 用来记录每一层的节点
        // 递归方向
        dfs(root.left, step + 1, result);
        dfs(root.right, step + 1, result);
    } 
}
```

### 2、广度优先搜索

广度优先搜索(Breadth First Search)(其实是**二叉树的层次遍历**)，又叫宽度优先搜索或横向优先搜索，是从根结点开始沿着树的宽度搜索遍历。

```javascript
var levelOrder = function(root) {
    if(!root) return [];
    let queue = [root];  // 队列，记录当前层的结点
    let result = [];
    let step = 0; // 本质就是表示二叉树的深度

    // 广度优先搜索(Breadth First Search)(其实是二叉树的层次遍历),又叫宽度优先搜索或横向优先搜索，是从根结点开始沿着树的宽度搜索遍历
    while(queue.length){
        result[step] = [];
        let len = queue.length; // 每一层节点个数，即queue的长度

        while(len){
            // shift()用于把数组的第一个元素从其中删除，并返回被删除的值。如果数组是空的，shift()方法将不进行任何操作，返回undefined的值
            let first = queue.shift();
            result[step].push(first.val);
            // console.log(first)
            if(first.left) queue.push(first.left);
            if(first.right) queue.push(first.right);
            len--;
        }
        step++;
        // console.log(queue)
    }
    return result;
};
```

### 3、二叉树的深度

来源：[剑指 Offer 55 - I. 二叉树的深度](https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/)

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */

// 广度优先搜索
var maxDepth = function(root) {
    let deep = 0;
    let queue = [root];
    if(!root) return 0;

    while(queue.length){
        // console.log(queue)
        let len = queue.length;
        deep ++;

        while(len){
            let node = queue.shift();
            if(node.left) queue.push(node.left);
            if(node.right) queue.push(node.right);
            len --;
        }
    }
    return deep;
};


//递归
// 与求二叉树的最大深度一样的意思
// var maxDepth = function(root) {
//     return !root ? 0 : Math.max(maxDepth(root.left),maxDepth(root.right))+1;
// };
```

### 4、对称二叉树

来源：[101. 对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/)

给定一个二叉树，检查它是否是镜像对称的。

例如，二叉树 [1,2,2,3,4,4,3] 是对称的。

        1
       / \
      2   2
     / \ / \
    3  4 4  3
但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:

        1
       / \
      2   2
       \   \
       3    3
```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {boolean}
 */

// def 函数A（左树，右树）： 左树节点值等于右树节点值 , 函数A（左树的左子树，右树的右子树）和 函数A（左树的右子树，右树的左子树）均为真 才返回真

// 递归
var isSymmetric = function(root) {
    if(!root) return true;

    function isEqual(left,right){
        if(!left && !right) return true;

        if(!left || !right) return false; // 一边有，一边没有，肯定不对称

        return left.val == right.val && isEqual(left.left,right.right) && isEqual(left.right,right.left);
    }

    return isEqual(root.left,root.right);
};
```

考点：**递归**

另一种中序遍历：324 1 423 （是否考虑用栈，或者中序遍历后再分割）

### 5、平衡二叉树

来源：[剑指 Offer 55 - II. 平衡二叉树](https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/)

输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。

示例 1:

给定二叉树 [3,9,20,null,null,15,7]

        3
       / \
      9  20
        /  \
       15   7
返回 true 。

示例 2:

给定二叉树 [1,2,2,3,3,null,null,4,4]

           1
          / \
         2   2
        / \
       3   3
      / \
     4   4
返回 false 。

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
// 平衡二叉树又称AVL树，空子树也是平衡二叉树
// 它或者是颗空树，或者是具有下列性质的二叉树：
    // 它的左子树和右子树都是平衡二叉树，且左子树和右子树的深度之差的绝对值不超过1。
    // 若将二叉树节点的平衡因子BF定义为该节点的左子树的深度减去它的右子树的深度，则平衡二叉树上所有节点的平衡因子只可能为-1,0,1.
    // 只要二叉树上有一个节点的平衡因子的绝对值大于1，那么这颗平衡二叉树就失去了平衡。

var isBalanced = function(root) {
    if(!root) return true;

    var leftHeight = getNodeHeight(root.left);
    var rightHeight = getNodeHeight(root.right);

    // Math.abs()取绝对值
    return Math.abs(leftHeight - rightHeight) > 1 ? false: isBalanced(root.left) && isBalanced(root.right);  // 继续判断下一个节点的左右子树是否为平衡二叉树
};

function getNodeHeight(root){
    if(!root){
        return 0;
    }

    return Math.max(getNodeHeight(root.left),getNodeHeight(root.right)) + 1;
}
```

### 6、在二叉树中找到两个节点的最近公共祖先

来源：[ NC102 在二叉树中找到两个节点的最近公共祖先 ](https://www.nowcoder.com/practice/e0cc33a83afe4530bcec46eba3325116?tpId=188&&tqId=38564&rp=1&ru=/activity/oj&qru=/ta/job-code-high-week/question-ranking)

给定一棵二叉树(保证非空)以及这棵树上的两个节点对应的val值 o1 和 o2，请找到 o1 和 o2 的最近公共祖先节点。

要求：空间复杂度O*(1)，时间复杂度 O(n)*

注：本题保证二叉树中每个节点的val值均不相同。

如当输入`[3,5,1,6,2,0,8,#,#,7,4],5,1`时，二叉树`{3,5,1,6,2,0,8,#,#,7,4}`如下图所示：

![img](https://uploadfiles.nowcoder.com/images/20211014/423483716_1634206667843/D2B5CA33BD970F64A6301FA75AE2EB22)

所以节点值为5和节点值为1的节点的最近公共祖先节点的节点值为3，所以对应的输出为3。

> 示例1:
>
> 输入：
>
> ```
> [3,5,1,6,2,0,8,#,#,7,4],5,1
> ```
>
> 返回值：
>
> ```
> 3
> ```

```javascript
/*
 * function TreeNode(x) {
 *   this.val = x;
 *   this.left = null;
 *   this.right = null;
 * }
 */

/**
 * 
 * @param root TreeNode类 
 * @param o1 int整型 
 * @param o2 int整型 
 * @return int整型
 */
function lowestCommonAncestor( root ,  o1 ,  o2 ) {
    //遇到叶子节点返回null
    if(root === null) {
        return null;
    }
    //如果o1或o2为根节点，则o1或o2为最近公共祖先
    if(root.val === o1 || root.val === o2) {
        return root.val;
    }
    // 在左子树寻找o1和o2的最近公共祖先
    let left = lowestCommonAncestor( root.left ,  o1 ,  o2 );
    // 在右子树寻找o1和o2的最近公共祖先
    let right = lowestCommonAncestor( root.right ,  o1 ,  o2 );
    // 如果o1和o2分属两侧，则根节点为最近公共祖先
    if(left !== null && right !== null) {
        return root.val;
    }
    // 如果左子树有值，则最近公共祖先在左子树，否则，在右子树
    return left !== null ? left : right;
}
module.exports = {
    lowestCommonAncestor : lowestCommonAncestor
};
```

另一种方法：深度优先搜索

```javascript
var lowestCommonAncestor = function(root, p, q) {
    if(!root)   return null;            //如果根节点为空的话，直接返回null
    let result;            //定义返回值
    const dfs = (root, p, q) => {
        //先定义深度遍历递归的条件
        if(!root)   return false;
        let lson = dfs(root.left, p, q);        //先从左子树开始深度遍历
        let rson = dfs(root.right, p, q);       //再从右子树开始深度遍历
        if((lson && rson) || ((root === q || root === p) && (lson || rson))) {
            //如果符合该条件的话，就是找到了最近的公共祖先节点
            result = root;
        }
        //只要有一项符合要求的话，就返回true
        return lson || rson || root === p || root === q;
    }
    dfs(root, p, q);
    return result;
};
```

