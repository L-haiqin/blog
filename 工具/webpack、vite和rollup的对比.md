面试题1：webpack、vite、rollup最根本的区别？

> 支持的模块
>
> 冷启动的预分析并打包

面试题2：为什么esm模版编译比较快？(考虑一下esm的静态导入方式)

> 1. **浏览器原生支持，跳过预编译**
>
> 传统工具（如 Webpack 4 及以前）在开发时需将所有模块打包成 bundle（如 `main.js`），浏览器加载时需解析整个文件。而 ESM 允许浏览器**直接请求单个模块文件**，开发服务器（如 Vite）只需按需返回原始文件，省去打包时间。
>
> 2. **按需执行，减少冗余计算**
>
> ESM 采用「静态导入」语法（`import xxx from './a.js'`），工具可在编译时**分析依赖关系**（构建关系图），仅处理实际用到的模块。相比之下，CommonJS（`require`）是动态加载，工具难在静态分析阶段优化。
>
> 3. **缓存策略更高效**
>
> 浏览器会缓存 ESM 模块的 HTTP 请求（如 `GET /src/button.js`），而传统打包后的 bundle 是单一文件，修改一个模块需重新加载整个文件，缓存失效成本高。
>
> 预构建缓存：第三方依赖（如 `node_modules`）通过 esbuild 预编译为 ESM 并缓存，避免重复构建

面试题3：按需编译的实现原理

| 维度           | webpack                                       | vite                                                         | rollup                                                       |
| -------------- | --------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **打包原理**   | 预分析依赖关系，**全量打包**成 bundle         | 开发时**按需编译**（按需加载） esbuild 模块，生产环境用 Rollup 打包 | 静态分析依赖，生成扁平化代码                                 |
| **模块处理**   | 支持 CommonJS、AMD、ESM 等多种模块            | 专注ES模版，其他模块需要插件支持                             | 专注ES模版                                                   |
| **构建速度**   | 冷启动需全量分析依赖并打包，项目越大速度越慢  | 开发环境采用“无打包”模式，直接利用浏览器原生 ESM 按需编译，冷启动秒级完成 | 生产构建高效，但开发模式无内置服务器（无热更新），需手动配置 |
| **配置复杂度** | 高度灵活但配置复杂（Loader、Plugin 体系庞大） | 开箱即用，预设 React/Vue 等模板，配置简洁                    | 配置相对简单，但需插件支持 CSS 等非 JS 资源                  |
| **应用场景**   | 大型企业级应用，传统项目或兼容旧浏览器        | 现代框架项目（Vue/React）                                    | js库或者sdk                                                  |

![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bf2c472e44714dafa5bebcd03822e492~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)



![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1c02296864e54069b798356f172fc34b~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)